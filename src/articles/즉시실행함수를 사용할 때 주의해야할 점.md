# 즉시 실행 함수(IIFE)

자바스크립트의 함수는 몇 가지의 종류가 있다.

그 종류로는 일반함수, 메서드 함수(클래스 메서드 축약표현), 화살표 함수, 즉시실행함수 등이 있다.

이 중에서 즉시실행함수(이하 IIFE 라고 칭하겠다.)는 말 그대로 즉시 실행되는 함수이다.

간단하게 예시를 들어보겠다.

```js
// IIFE Example
var bar = (function () {})();
```

일반적인 즉시실행함수의 패턴이다.

자바스크립트의 클로저를 배울 때 많이 보게 될 형태이다.

필자는 처음 이 패턴을 보고 많이 당황했었다.

함수를 정의하는 부분이 그룹 연산자(`'(', ')'`) 로 변환될 수 있는 것인지, 그리고 저런 식으로 호출되는 것이 가능한 것인지 몰랐기 때문에 코드를 해석하는 것이 힘들었다.



## 표현식과 문(expression 과 statement)

필자가 IIFE를 이해하는 것에 도움을 준 용어는 표현식과 문이었다. (물론 여기에 값 이라는 용어도 추가된다.)

[자바스크립트 DeepDive](https://product.kyobobook.co.kr/detail/S000001766445) 에서 찾을 수 있다.

값, value 는 표현식이 평가되어 생성된 결과이다.

표현식은 값으로 평가될 수 있는 문이다.

문은 최소 실행 단위, 명령문 이라고 부른다.



## 리터럴(literal)

리터럴이란 값으로 평가되는 사람이 이해하기 쉬운 표기법을 의미한다.

예시를 들어보겠다.

```js
// Boolean Literal
true
false

// Object Literal
{ foo : 'bar', one : 'two'}

// Function Literal
function () {}
```

우리가 사용하는 것들은 리터럴로 이뤄져있다고 말할 수 있다.

이러한 리터럴들은 값으로 평가된다.

이것은 표현식의 의미와 동일하다.



필자가 IIFE를 해석하는 것에 어려움을 겪은 이유는 함수 리터럴이 값으로 평가된다는 것을 몰랐기 때문이다.

```js
function foo () {
  // statement...
}
```

이러한 형식만이 가능한 줄 알았기 때문에 IIFE의 형태가 왜 가능한지 몰랐다.



## 즉시 실행 함수의 해석

```js
// IIFE Example
var bar = (function () {})();
```

위의 코드를 해석해보자.

먼저 `(function () {})` 는 함수 리터럴을 그룹 연산자로 묶는 것으로 값으로 평가하고 있다.

함수는 객체이며, 동시에 callable(호출 가능한) 하다.

그래서 우리는 이 객체를 호출할지 아니면 `var bar` 객체에 할당할 지 선택할 수 있다.



여기에서는 `(function () {})()` 으로 함수를 호출하고 있다.

그렇다면, `var bar` 에는 무엇이 할당될까?

그룹 연산자로 쌓인 함수의 결과값이 할당된다. `undefined | 함수의 return 값` 이 할당될 것이다.



## 즉시 실행 함수의 사용 사례

### Closure

일반적으로 많이 사용되는 예시는 클로저로 많이 사용된다.

```js
var Count = (function () {
  let count = 0
  
  
  return function increase () {
    return ++num;
  }
})();
```

count 변수를 외부에 노출하지 않는 것으로 변수의 의도치 않은 변경을 방지하기 위해서 사용한다.





## 에러 예시

IIFE 를 사용할 때는 어디에서 끊기는지 확인하는 것이 중요하다.

자바스크립트에서는 세미콜론을 사용하는 것으로 코드의 끝을 판단한다.

밑의 예시는 세미콜론의 위치에 따라서 에러가 발생하였다.

```js
var bar = function () {}(function () {})();
// TypeError : Intermediate value
```

위의 코드를 해석해보자.

먼저 해석을 편하게 하기 위해서 익명함수를 기명함수로 바꿔보자.

```js
var bar = function foo() {}(function bar () {})();
```

먼저 뒤에 있는 그룹 연산자 (호출을 하기 위한)를 제외하면 bar 함수는 foo 함수의 인수로 전달되는 IIFE 이다.

(foo 함수에는 매개변수가 없지만 arguments 객체는 모든 인수를 기억해줄 것이다.)

만약 이 함수가 foo 함수를 IIFE로 동작하도록 의도되었다면?

```js
var bar = function foo() {}(function bar () {});
();
```

이런 식으로 변경할 수 있을 것이다.

하지만, 이러한 동작을 의도했다면, 그룹연산자는 필요없는 코드가 된다.

그렇다면 추측할 수 있는 것은 bar 변수에 foo 함수를 할당하고 bar 함수를 IIFE 로 동작하도록 하는 것이다.

```js
var bar = function foo() {};
(function bar () {})();
```

이것이 의도한 동작에 맞는 코드가 된다.



IIFE 는 함수도 값으로 평가된다는 것을 기억하면 쉽게 해석할 수 있다. 지금 코드가 위치한 자리가 어떻게 평가되는 지를 알면 충분히 해석할 수 있다.